\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\title{%
	Obliczenia naukowe \\
	\large Lista 1}
\author{Szymon Janiak}
\begin{document}
\maketitle

\section{Zadanie 1}
\subsection{Macheps}
	$macheps$ to najmniejsza liczba $> 0$ taka, że $fl(1.0 + macheps) > 1.0$ i $fl(1.0 + macheps) = 1 + macheps$
\subsubsection{Opis problemu}
	Wyznaczenie iteracyjnie epsilonów maszynowych dla wszystkich dostępnych typów zmiennopozycyjnych Float16, Float32, Float64, zgodnych ze standardem IEEE 754.
\subsubsection{Rozwiązanie}
	\begin{algorithm}
	\caption{$macheps$ iteracyjnie}\label{alg:cap}
	\begin{algorithmic}
        \State $x \gets 1.0$
        \State $macheps \gets 1.0$
        \For{ $i$ to $50$ }
            \If{ $x + \frac{macheps}{2} = x$ }
            	\State break
            \EndIf
            \State $macheps \gets \frac{macheps}{2}$
        \EndFor
        \State \textbf{return} $macheps$
    \end{algorithmic}
    \end{algorithm}

\subsubsection{Wyniki}
	\begin{center}
        \begin{tabular}{|c||c|c|c|}
        \hline
            Źródło & Float16 & Float32 & Float64 \\
            \hline\hline
            Mój algorytm & 0.000977 & 1.1920929e-7 & 2.220446049250313e-16\\
            \hline
            eps() & 0.000977 & 1.1920929e-7 & 2.220446049250313e-16\\
            \hline
            float.h & - & 1.19209e-07 & 2.22045e-16 \\
        \hline
        \end{tabular}
    \end{center}

\subsection{Eta}
	$eta$ to najmniejsza liczba taka, że $eta > 0.0$
\subsubsection{Opis Problemu}
    Wyznaczenie iteracyjnie liczb maszynowych eta dla wszystkich dostępnych typów zmiennopozycyjnych Float16, Float32, Float64, zgodnych ze standardem IEEE 754.
\subsubsection{Rozwiązanie}
    \begin{algorithm}
    \caption{$eta$ iteracyjnie}\label{alg:cap}
    \begin{algorithmic}
        \State $x \gets 1.0$
        \State $macheps \gets 1.0$
        \For{ $i$ to $1100$ }
            \If{ $\frac{macheps}{2} = 0.0$ }
            	\State break
            \EndIf
            \State $macheps \gets \frac{macheps}{2}$
        \EndFor
        \State \textbf{return} $macheps$
    \end{algorithmic}
    \end{algorithm}

\subsubsection{Wyniki}
    \begin{center}
        \begin{tabular}{|c||c|c|c|}
        \hline
            Źródło & Float16 & Float32 & Float64 \\
            \hline\hline
            Mój algorytm & 6.0e-8 & 1.0e-45 & 5.0e-324\\
             \hline
             nextfloat(0.0) & 6.0e-8 & 1.0e-45 & 5.0e-324\\
        \hline
        \end{tabular}
    \end{center}

\section{Zadanie 2}
\subsection{Twierdzenie Khan'a}
	Epislon maszynowy $macheps$ można otrzymać obliczając wyrażenie $3.0*(\frac{4.0}{3.0} - 1.0) - 1.0$
\subsection{Opis Problemu}
    Sprawdzenie czy stwierdzenie Khan'a jest słuszne dla wszystkich typów zmiennopozycyjnych Float16, Float32, Float64.
\subsection{Wyniki}
    \begin{center}
        \begin{tabular}{|c||c|c|c|}
        \hline
            Źródło & Float16 & Float32 & Float64 \\
            \hline\hline
            Khan & -0.000977 & 1.1920929e-7 & -2.220446049250313e-16\\
            \hline
            eps() & 0.000977 & 1.1920929e-7 & 2.220446049250313e-16\\
        \hline
        \end{tabular}
    \end{center}
\subsection{Wnioski}
    Wyniki z wyrażenia od Khan'a różnią się znakiem dla Float16 i Float64.

\section{Zadanie 3}
\subsection{Opis Problemu}
	Sprawdzenie rozmieszczenia liczb zmiennoprzecinkowych Float64 w standardzie IEEE 754 w przedziałach [1, 2], [$\frac{1}{2}$, 1] oraz [2, 4].
\subsection{Rozwiązanie}
	$\delta$ - krok o który będziemy powiększać początkowe liczby
    Obserwując otrzymywane wyniki, będziemy mogli dostować wielkośc kroku, aby uzyskać zwiększenie o jeden bit na danym przedziale
\subsection{Wyniki}
	$\delta=2^{-52}$ dla przedziału [1, 2]: 
	Różnica po jednym kroku\\
	0011111111110000000000000000000000000000000000001010110011000001 -- 1.00000000000982\\
	0011111111110000000000000000000000000000000000001010110011000010 -- 1.0000000000098201\\
	$\delta=\frac{2^{-52}}{2}$ dla przedziału [$\frac{1}{2}$, 1]:
	Tutaj musieliśmy podzielić krok przez 2 aby uzyskac taki sam rezultat jak wcześniej 
	Różnica po jednym kroku\\
	0011111111100000000000000000000000000000000000001001001101001100 -- 0.5000000000041864\\
	0011111111100000000000000000000000000000000000001001001101001101 -- 0.5000000000041865\\
	$\delta=2^{-52} * 2$ dla przedziału [2, 4]:
	Tutaj sytuacja odwrotna, długość kroku musiała zostać zwiększona
	Różnica po jednym kroku\\
	0100000000000000000000000000000000000000000000000111110111011101 -- 2.000000000014309\\
	0100000000000000000000000000000000000000000000000111110111011110 -- 2.0000000000143094\\
\subsection{Wnioski}
	W przedziale [1, 2] liczby występują co $\delta=2^{-52}$.\\
	W przedziale [$\frac{1}{2}$, 1] 2 razy częsciej, a w przedziale [2, 4] 2 razy rzadziej.

\end{document}