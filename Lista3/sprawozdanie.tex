\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 11in}]{geometry}
\usepackage{algorithm}
\usepackage{amsfonts}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subcaption}

\title{%
	Obliczenia naukowe \\
	\large Lista 3}
\author{Szymon Janiak}
\begin{document}
\maketitle

\section*{Zadanie 1}
\subsection*{Opis problemu}
	Napisać funkcję rozwiązującą równanie $f(x) = 0$ metodą bisekcji.
\subsubsection*{Dane wejściowe}
	\begin{itemize}
	    \item \texttt{f} — funkcja $f$ w postaci anonimowej funkcji
	    \item \texttt{a,b} — liczby typu \texttt{Float64} określające końce przedziału początkowego
	    \item \texttt{delta, epsilon} — liczby typu \texttt{Float64} określające dokładności obliczeń
	\end{itemize}
	Czwórka wartości \texttt{(r, val, it, err)}.
	\begin{itemize}
	    \item \texttt{r} — przybliżenie pierwiastka równania $f(x) = 0$
	    \item \texttt{val} — wartość funkcji w $r$
	    \item \texttt{it} — liczba wykonanych iteracji
	    \item \texttt{err} — sygnalizacja błędu, możliwe wartości:
	    \begin{itemize}
	        \item \texttt{0} — brak błędu
	        \item \texttt{1} — funkcja nie zmienia znaku w przedziale $[a;b]$
	    \end{itemize}
	\end{itemize}
\subsubsection*{Opis algorytmu}
	Metoda bisekcji polega na stopniowym zawężaniu przedziału szukania naszego pierwiastka do momentu, gdy nasz wynik będzie wystarczająco bliski, co do zależne jest od zdefiniowanego przez nas $\epsilon$.
	Do zastosowania tej metody potrzebne są spełnione dwa założenia:
	\begin{itemize}
		\item funkcja \texttt{$f(x)$} jest ciągła w przedziale domkniętym $[a, b]$,
		\item funkcja przyjmuje różne znaki na końcach przedziału.
	\end{itemize}
	Kolejne iteracje algorytmu przesuwają jedną z granic przedziału bliżej pierwiastka o połowe długości przedziału. Wybór końca do przesunięcia polega na sprawdzeniu które przesunięcie zwróci nam przedział, który spełnia warunek zmiany znaku w naszym nowym przedziale.
\subsubsection*{Rozwiązanie}
	\begin{algorithm}[H]
	\caption{bisection method}
	\begin{algorithmic}
		\State $val \gets 0$
        \State $it \gets 0$
        \State $e \gets b - a$
        \State $u \gets f(a)$
        \State $v \gets f(b)$
        \State $r \gets \frac{1}{2} * (a + b)$
        \If{ $sign(u) = sign(v)$}
        	\State $err \gets 1$
        	\State return $r, val, it, err$
        \EndIf

        \While{$|e| > \epsilon$ and $|f(r)| > \delta$}
        	\State $e \gets frac{e}{2}$
        	\State $r \gets a + e$
        	\State $val \gets f(r)$
        	\State $it \gets it + 1$
        	\If{ $|e| < \delta$ or $|val| < \epsilon$ }
        		\State return $r, val, it, err$
        	\EndIf

        	\If{ $sign(val) \neq sign(u)$ }
        		\State $g \gets r$
        		\State $v \gets val$
        	\Else
        		\State $a \gets r$
        		\State $u \gets val$
        	\EndIf
        \EndWhile

        \State return $r, val, it, err$
    \end{algorithmic}
    \end{algorithm}

\section*{Zadanie 2}
\subsection*{Opis problemu}
	Napisać funkcję rozwiązującą równanie $f(x) = 0$ metodą Newtona.
\subsubsection*{Dane wejściowe}
	\begin{itemize}
	    \item \texttt{f} — funkcja $f$ w postaci anonimowej funkcji
	    \item \texttt{pf} — pochodna funkcji $f$ w postaci anonimowej funkcji
	    \item \texttt{x0} — przybliżenie początkowe
	    \item \texttt{delta, epsilon} — liczby typu \texttt{Float64} określające dokładności obliczeń
	    \item \texttt{maxit} — liczba całkowita określająca dopuszczalną liczbę iteracji
	\end{itemize}
\subsubsection*{Dane wyjściowe}
	Czwórka wartości \texttt{(r, val, it, err)}.
	\begin{itemize}
	    \item \texttt{r} — przybliżenie pierwiastka równania $f(x) = 0$
	    \item \texttt{val} — wartość funkcji w $r$
	    \item \texttt{it} — liczba wykonanych iteracji
	    \item \texttt{err} — sygnalizacja błędu, możliwe wartości:
	    \begin{itemize}
	        \item \texttt{0} — metoda zbieżna
	        \item \texttt{1} — nie osiągnięto wymaganej dokładności w \texttt{maxit} iteracji
	        \item \texttt{2} — pochodna bliska zeru
	    \end{itemize}
	\end{itemize}
\subsubsection*{Opis algorytmu}
	W tym algorytmie potrzebujemy założyć, że w naszym przedziale $[a, b]$ znajduje sie dokładnie jeden pierwiastek funkcji $f$, oraz różne znaki funkcji na krańcach przedziału. Dodatkowym wymaganiem jest stały znak pierwszej i drugiej pochodnej funkcji w tym przedziale.
	Na początku przyjmujemy sobie za $x_1$ granicę $a$ lub $b$ i wyznaczamy równanie stycznej do wykresu funkcji w punkcie $[x_1, f(x_1)]$, następnie wyznaczamy odciętą $x_2$ punktu przecięcia tej stycznej z osią OX - w ten sposób otrzymujemy kolejne przybliżenie naszego rozwiązania.\tabularnewline
	Całą procedurę powtarzamy do momentu gdy otrzymamy wynik mieszczący się w naszym $\epsilon$ tworząc kolejne styczne.
\subsubsection*{Rozwiązanie}
	\begin{algorithm}[H]
	\caption{Newton method}
	\begin{algorithmic}
		\State $val \gets f(x_0)$
        \State $val\_prime \gets 0$
        \State $x_1 \gets 0$
        \State $it \gets 1$
        \If{ $abs(v) < \epsilon$}
        	\State $err \gets 0$
        	\State return $x_0, val, it, err$
        \EndIf

        \For{ $it$ to $maxit$ }
        	\State $val\_prime \gets pf(x_0)$
        	\State $x_1 = x_0 - \frac{val}{val\_prime}$
        	\State $val \gets f(x_1)$

        	\If{ $|val\_prime| \le NEAR\_ZERO$ or $IsInf(|val\_prime|)$}
        		\State $err \gets 2$
        		\State return $x_0, f(x_0), it, err$
        	\EndIf

        	\If{ $|x_1 - x_0| < \delta$ or $|val| < \epsilon$}
        		\State return return $x_1, val, it, err$
        	\EndIf

        	\State $x_0 \gets x_1$
        \EndFor

        \State $err \gets 1$
        \State return $x_0, val, it, err$
    \end{algorithmic}
    \end{algorithm}
\clearpage

\section*{Zadanie 3}
\subsection*{Opis problemu}
	Napisać funkcję rozwiązującą równanie $f(x) = 0$ metodą siecznych.
\subsubsection*{Dane wejściowe}
	\begin{itemize}
	    \item \texttt{f} — funkcja $f$ w postaci anonimowej funkcji
	    \item \texttt{x0,x1} — przybliżenia początkowe
	    \item \texttt{delta, epsilon} — liczby typu \texttt{Float64} określające dokładności obliczeń
	    \item \texttt{maxit} — liczba całkowita określająca dopuszczalną liczbę iteracji
	\end{itemize}
\subsubsection*{Dane wyjściowe}
	Czwórka wartości \texttt{(r,v,it,err)}.
	\begin{itemize}
	    \item \texttt{r} — przybliżenie pierwiastka równania $f(x) = 0$
	    \item \texttt{v} — wartość funkcji w $r$
	    \item \texttt{it} — liczba wykonanych iteracji
	    \item \texttt{err} — sygnalizacja błędu, możliwe wartości:
	    \begin{itemize}
	        \item \texttt{0} — metoda zbieżna
	        \item \texttt{1} — nie osiągnięto wymaganej dokładności w \texttt{maxit} iteracji
	    \end{itemize}
	\end{itemize}
\subsubsection*{Opis algorytmu}
	Do użycia tej metody potrzebujemy dwa punkty startowe $x_0$ i $x_1$, których będziemy używać do wyznaczania następnych przybliżeń. Obliczamy $f(x_0)$ i $f(x_1)$, a następnie poprowadzamy przez te dwa punkty sieczną. Przecięcie siecznej z osią OX wyznaczy nam punkt do następnej iteracji. W ten sposób będziemy wyznaczać coraz to bliższe przybliżenia funkcji używając do tego zawsze dwóch wartości $x_n$ oraz $x_{n+1}$.
	Metoda ta nie zawsze jest zbieżna.
\subsubsection*{Rozwiązanie}
	\begin{algorithm}[H]
	\caption{secant method}
	\begin{algorithmic}
		\State $it \gets 0$
		\State $a \gets x_0$
		\State $b \gets x_1$
		\State $val \gets f(x_0)$
		\State $val\_next \gets f(x_1)$

		\For{ $it$ to $maxit$}
			\If{ $|val| > |val\_next|$}
				\State $a, b = b, a$
				\State $val, val\_next \gets val\_next, val$
			\EndIf

			\State $d \gets \frac{b - a}{val\_next - val}$
			\State $b \gets a$
			\State $val\_next \gets val$

			\State $a \gets a - d * val$
			\State $val \gets f(a)$

			\If{ $|val| < \epsilon$ or $|b - a| < delta$}
				\State return $a, val, it ,err$
			\EndIf
		\EndFor

		\State $err \gets 1$
		\State return $a, val, it, err$
    \end{algorithmic}
    \end{algorithm}
\end{document}